#!/usr/bin/perl
=pod

=head1 NAME

  rmshit - keep a directory structure clean at all times

=head1 SYNOPSIS
  
  rmshit [OPTION]

=head1 DESCRIPTION

B<rmshit> was born out of plain rage and frustation, seeing that nobody seems to
care about the XDG specifications, and dumping configuration files, temporary
data and logs straight into $HOME.

Even if you manually delete these files, they will be recreated when the
Application of Sin wants to (when it's executed, seeing default data is missing,
for example).

The most well known application that does this, as of this writing, is Mozilla
Firefox, creating $HOME/Desktop, over and over again.

rmshit uses inotify to keep an eye on a directory structure, instantly removing
data upon it's creation.

=head1 OPTIONS

  -k, --kill    kill a running rmshit process
  -h, --help    this help
  -m, --man     manpage

=head1 ENVIRONMENT

rmshit watches the directories you specify in the configuration file. It should
be placed in $XDG_CONFIG_HOME/rmshit/rmshit.conf or
$HOME/.config/rmshit/rmshit.conf.

=head1 REPORTING BUGS

Report bugs to trapd00r@trapd00r.se

rmshit homepage: http://github.com/trapd00r/rmshit

=head1 COPYRIGHT

Copyright 2010 Magnus Woldrich. License GPLv2: GNU GPL version 2 or later

=cut


our $VERSION = 0.5;
=rmshit
  rmshit
  instantly deletes the cocksucking good for nothing motherfucking piece of
  shitty files that firefox/gtk/gconf/etc stupid apps creates

  For more rage and discussion see:
  http://bbs.archlinux.org/viewtopic.php?id=97979
=cut

my $DEBUG = undef;

use strict;
use Carp;
use Linux::Inotify2;
use File::Path qw(remove_tree mkpath);
use Getopt::Long;
use Pod::Usage;
use Data::Dumper;

my $inotify = Linux::Inotify2->new;
my $logdir = $ENV{XDG_DATA_HOME}; # $HOME/.local/share here
$logdir = "$ENV{HOME}/.local" if $logdir eq "";
my $log = "$logdir/rmshit/rmshit.log";

my $pidfile = '/tmp/rmshit.pid';

if(!-d "$logdir") {
  mkpath("$logdir/rmshit", 1, 0777) 
    or croak "Cant mkpath $logdir/rmshit: $!";
}


my %inotifyEvents = (
  '1'          => 'IN_ACCESS',       # file was accessed
  '2'          => 'IN_MODIFY',       # file was modified
  '4'          => 'IN_ATTRIB',       # metadata has changed
  '8'          => 'IN_CLOSE_WRITE',  # writeable file was closed
  '16'         => 'IN_CLOSE_NOWRITE',# unwriteable file was closed
  '32'         => 'IN_OPEN',         # file was opened
  '64'         => 'IN_MOVED_FROM',   # file was moved from X
  '128'        => 'IN_MOVED_TO',     # file was moved to Y
  '256'        => 'IN_CREATE',       # subfile was created
  '512'        => 'IN_DELETE',       # subfile was deleted
  '1024'       => 'IN_DELETE_SELF',  # self/dir was deleted
  '2048'       => 'IN_MOVE_SELF',    # self was moved
  '8192'       => 'IN_UNMOUNT',      # fs was unmounted
  '16384'      => 'IN_O_OVERFLOW',   # Even queued overflowed
  '32768'      => 'IN_IGNORED',      # file was ignored
  '1073741824' => 'IN_ISDIR',        # event occurred against dir
);

if($DEBUG) {
  require './rmshit.conf';
}
else {
  eval { 
    require "$ENV{XDG_CONFIG_HOME}/rmshit/rmshit.conf";
  };
  if($@) {
    require "/etc/rmshit.conf";
  }
  else {
    require "$ENV{XDG_CONFIG_HOME}/rmshit/rmshit.conf";
  }
}

our ($watchdir,%shittyfiles); # imported from the config file
my @date = localtime();
my $nicetime = sprintf("%d-%02d-%02d %02d:%02d:%02d",
  $date[5]+1900, $date[4], $date[3], $date[2], $date[1], $date[0]);

for my $dir(keys(%shittyfiles)) {
  for my $file(@{$shittyfiles{$dir}}) {
    if(-d "$dir/$file") {
      if(remove_tree("$dir/$file")) {
        open(my $fh, '>>', $log);
        print $fh "[PD] $nicetime: ", "$dir/$file\n";
        close($fh);
      }
    }
    if(-f "$dir/$file") {
      if(unlink("$dir/$file")) {
        open(my $fh, '>>', $log);
        print $fh "[PF] $nicetime: ", "$dir/$file\n";
        close($fh);
      }
    }
  }
}

GetOptions(
  kill    => \&killkid,
  help    => sub {pod2usage(-verbose => 1)},
  man     => sub {pod2usage(-verbose => 3)},
);

$inotify->watch($watchdir, IN_CREATE) or die;

sub daemonize {
  use POSIX 'setsid';
  my $PID = fork();
  exit(0) if($PID); # p
  exit(1) if(!defined($PID));

  setsid();
  $PID = fork();
  exit(1) if(!defined($PID));

  if($PID) {
    waitpid($PID,0);
    unlink($pidfile);
    exit(0);
  }
  elsif($PID == 0) { #c
    open(my $fh, '>', $pidfile) or die($!);
    print $fh $$;
    close($fh);
    open(STDOUT, '>', '/dev/null'); # better use normal prints and reopen STDOUT
                                    # to $log...
    open(STDERR, '>', '/dev/null');
    open(STDIN,  '<', '/dev/null');
  }
}

sub killkid {
  open(my $fh, '<', $pidfile) or print "rmshit is not running\n" and exit(1);
  my $target= <$fh>;
  close($fh);

  if(kill(9, $target)) {
    print "$target destroyed\n";
  }
  else {
    print "$target hmm...\n";
  }
  exit(0);
}

daemonize();

while () {
  my @events = $inotify->read;
  unless (@events > 0) {
    print "read error: $!";
    last;
  }
  foreach my $event(@events) {
    foreach my $shitfile(@{$shittyfiles{$watchdir}}) {
      if($shitfile eq $event->name) { # remove the stupid piece of shit
        open(my $fh, '>>', $log);     # I'll let it freak out for now


        if(-d $event->fullname) {
          if(remove_tree($event->fullname)) {
            print $fh "[CD] $nicetime: ",$event->fullname,"\n"; 
          }
          else {
            print $fh "[ERROR] $nicetime: ", $event->fullname,"\n";
          }
        }
        else {
          if(unlink($event->fullname)) {
            print $fh " [CF] $nicetime: ", $event->fullname,"\n";
          }
          else {
            print $fh "[ERROR] $nicetime: ",$event->fullname,"\n";
          }
        }
        close $fh;
      }
    }
  }
}


